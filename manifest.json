{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"JUnit version 4.11-SNAPSHOT-20120416-1530\n.E...\nTime: 0.123\nThere was 1 failure:\n1) clash_when_medicines_taken_overlapping_start_of_period(PatientTest)\njava.lang.AssertionError: expected:<1> but was:<29>\n\tat PatientTest.clash_when_medicines_taken_overlapping_start_of_period(PatientTest.java:64)\n\nFAILURES!!!\nTests run: 4,  Failures: 1\n\n","instructions":"\nThis is an instructor-led exercise with no written instructions.\nYour instructor will explain the exercise.\n","PatientTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\nimport java.time.LocalDate;\nimport java.util.Arrays;\n\npublic class PatientTest {\n\n    @Test\n    public void no_clash_when_not_taking_both_medicines() {\n        Prescription prescription = \n            new Prescription(LocalDate.now().minusDays(30), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescription));\n        Patient patient = new Patient(codeine, null);\n\n        assertEquals(0, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90));\n    }\n\n    @Test\n    public void no_clash_when_no_overlap() {\n        Prescription prescriptionCodeine = \n            new Prescription(LocalDate.now().minusDays(90), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(LocalDate.now().minusDays(30), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(0, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90));\n    }\n\n    @Test\n    public void clash_when_medicines_taken_overlapping() {\n        Prescription prescriptionCodeine = \n            new Prescription(LocalDate.now().minusDays(30), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(LocalDate.now().minusDays(40), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(20, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90));\n    }\n\n    @Test\n    public void clash_when_medicines_taken_overlapping_start_of_period() {\n        Prescription prescriptionCodeine = \n            new Prescription(LocalDate.now().minusDays(91), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(LocalDate.now().minusDays(119), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(1, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90));\n    }\n\n    // TODO: clash_when_medicines_taken_overlapping_current_date\n    // TODO: clash_when_medicines_taken_continuously_with_the_same_period\n    // TODO: clash_when_medicines_taken_continuously_with_partial_overlap\n}\n","Patient.java":"import java.util.List;\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class Patient {\n    private Medicine medicine;\n    private Medicine clashingMedicine;\n    \n    public Patient(Medicine medicine, Medicine clashingMedicine) {\n        this.medicine = medicine;\n        this.clashingMedicine = clashingMedicine;\n    }\n\n    public long clash(List<String> medicineNames, long daysBeforeToday) {\n        if (this.medicine == null || this.clashingMedicine == null) {\n            return 0;\n        }\n        if (!isOverlapped(medicine, clashingMedicine, daysBeforeToday)) {\n            return 0;\n        }\n        return calculateOverlappedDays(medicine, clashingMedicine\n            , daysBeforeToday);\n    }\n\n    private boolean isOverlapped(Medicine medicine\n            , Medicine clashingMedicine\n            , long daysBeforeToday) {\n        LocalDate startA = getStartDate(medicine, daysBeforeToday);\n        LocalDate endA = getEndDate(medicine, daysBeforeToday);\n        LocalDate startB = getStartDate(clashingMedicine, daysBeforeToday);\n        LocalDate endB = getEndDate(clashingMedicine, daysBeforeToday);\n        \n        return !(startA.isAfter(endB) || endA.isBefore(startB)) \n            ? true : false;\n    }\n\n    private long calculateOverlappedDays(Medicine medicine\n            , Medicine clashingMedicine\n            , long daysBeforeToday) {\n        LocalDate startA = getStartDate(medicine, daysBeforeToday);\n        LocalDate endA = getEndDate(medicine, daysBeforeToday);\n        LocalDate startB = getStartDate(clashingMedicine, daysBeforeToday);\n        LocalDate endB = getEndDate(clashingMedicine, daysBeforeToday);\n\n        if (startA.isAfter(startB)) {\n            return startA.until(endB, ChronoUnit.DAYS);\n        } else {\n            return startB.until(endA, ChronoUnit.DAYS);\n        }\n    }\n\n    private LocalDate getStartDate(Medicine medicine, long daysBeforeToday) {\n        LocalDate dateAfterConsidered = \n            LocalDate.now().minusDays(daysBeforeToday);\n        LocalDate startDate = \n            medicine.getPrescriptions().get(0).getDispenseDate();\n        return dateAfterConsidered.isAfter(startDate) ?\n            dateAfterConsidered : startDate;\n    }\n\n    private LocalDate getEndDate(Medicine medicine, long daysBeforeToday) {\n        LocalDate dateAfterConsidered = \n            LocalDate.now().minusDays(daysBeforeToday);\n        LocalDate endDate = \n            medicine.getPrescriptions().get(0).getDispenseDate()\n            .plusDays(medicine.getPrescriptions().get(0)\n                .getDaysSupply());\n        return dateAfterConsidered.isAfter(endDate) ?\n            dateAfterConsidered : endDate;\n    }\n}","Medicine.java":"import java.util.List;\n\npublic class Medicine {\n    private List<Prescription> prescriptions;\n\n    public Medicine(String name, List<Prescription> prescriptions) {\n        this.prescriptions = prescriptions;\n    }\n\n    public List<Prescription> getPrescriptions() {\n        return this.prescriptions;\n    }\n}","Prescription.java":"import java.time.LocalDate;\n\npublic class Prescription {\n    private LocalDate dispenseDate;\n    private long daysSupply;\n\n    public Prescription(LocalDate dispenseDate, long daysSupply) {\n        this.dispenseDate = dispenseDate;\n        this.daysSupply = daysSupply;\n    }\n\n    public LocalDate getDispenseDate() {\n        return this.dispenseDate;\n    }\n\n    public long getDaysSupply() {\n        return this.daysSupply;\n    }\n}"}