{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"JUnit version 4.11-SNAPSHOT-20120416-1530\nI.>>>entering clash()\n>>>entering isOverlapped()\n>>>startA: 2015-12-16\n>>>endA: 2015-11-16\n>>>startB: 2015-12-16\n>>>endB: 2015-11-16\nEIIII\nTime: 0.1\nThere was 1 failure:\n1) clash_when_medicines_taken_continuously_with_the_same_period(PatientTest)\njava.lang.AssertionError: expected:<90> but was:<0>\n\tat PatientTest.clash_when_medicines_taken_continuously_with_the_same_period(PatientTest.java:106)\n\nFAILURES!!!\nTests run: 1,  Failures: 1\n\n","instructions":"\nThis is an instructor-led exercise with no written instructions.\nYour instructor will explain the exercise.\n","PatientTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\nimport java.time.LocalDate;\nimport java.util.Arrays;\n\npublic class PatientTest {\n\n    @Test @Ignore\n    public void no_clash_when_not_taking_both_medicines() {\n        LocalDate now = LocalDate.now();\n        Prescription prescription = \n            new Prescription(now.minusDays(30), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescription));\n        Patient patient = new Patient(codeine, null);\n\n        assertEquals(0, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90, now));\n    }\n\n    @Test @Ignore\n    public void no_clash_when_no_overlap() {\n        LocalDate now = LocalDate.now();\n        Prescription prescriptionCodeine = \n            new Prescription(now.minusDays(90), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(now.minusDays(30), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(0, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90, now));\n    }\n\n    @Test @Ignore\n    public void clash_when_medicines_taken_overlapping() {\n        LocalDate now = LocalDate.now();\n        Prescription prescriptionCodeine = \n            new Prescription(now.minusDays(30), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(now.minusDays(40), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(20, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90, now));\n    }\n\n    @Test @Ignore\n    public void clash_when_medicines_taken_overlapping_start_of_period() {\n        LocalDate now = LocalDate.now();\n        Prescription prescriptionCodeine = \n            new Prescription(now.minusDays(91), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(now.minusDays(119), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(1, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90, now));\n    }\n\n    @Test @Ignore\n    public void clash_when_medicines_taken_overlapping_current_date() {\n        LocalDate now = LocalDate.now();\n        Prescription prescriptionCodeine = \n            new Prescription(now.minusDays(1), 30);\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(prescriptionCodeine));\n        Prescription prescriptionProzac = \n            new Prescription(now.minusDays(5), 30);\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(prescriptionProzac));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(1, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90, now));\n    }\n\n    @Test\n    public void clash_when_medicines_taken_continuously_with_the_same_period() {\n        LocalDate now = LocalDate.now();\n        Medicine codeine = new Medicine(\"Codeine\", \n            Arrays.asList(\n                new Prescription(now.minusDays(30), 30)\n                , new Prescription(now.minusDays(60), 30)\n                , new Prescription(now.minusDays(90), 30)\n            ));\n        Medicine prozac = new Medicine(\"Prozac\", \n            Arrays.asList(\n                new Prescription(now.minusDays(30), 30)\n                , new Prescription(now.minusDays(60), 30)\n                , new Prescription(now.minusDays(90), 30)\n            ));\n        Patient patient = new Patient(codeine, prozac);\n\n        assertEquals(90, \n            patient.clash(Arrays.asList(\"Codeine\", \"Prozac\"), 90, now));\n    }\n\n    // TODO: clash_when_medicines_taken_continuously_with_partial_overlap\n}\n","Patient.java":"import java.util.List;\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class Patient {\n    private Medicine medicine;\n    private Medicine clashingMedicine;\n    \n    public Patient(Medicine medicine, Medicine clashingMedicine) {\n        this.medicine = medicine;\n        this.clashingMedicine = clashingMedicine;\n    }\n\n    public long clash(List<String> medicineNames, long daysBeforeToday\n            , LocalDate now) {\n        System.out.println(\">>>entering clash()\");\n        if (this.medicine == null || this.clashingMedicine == null) {\n            return 0;\n        }\n        if (!isOverlapped(medicine, clashingMedicine\n                , daysBeforeToday, now)) {\n            return 0;\n        }\n        return calculateOverlappedDays(medicine, clashingMedicine\n            , daysBeforeToday, now);\n    }\n\n    private boolean isOverlapped(Medicine medicine\n            , Medicine clashingMedicine\n            , long daysBeforeToday, LocalDate now) {\n        System.out.println(\">>>entering isOverlapped()\");\n        LocalDate startA = getStartDate(medicine);\n        LocalDate endA = getEndDate(medicine);\n        LocalDate startB = getStartDate(clashingMedicine);\n        LocalDate endB = getEndDate(clashingMedicine);\n        System.out.println(\">>>startA: \" + startA);\n        System.out.println(\">>>endA: \" + endA);\n        System.out.println(\">>>startB: \" + startB);\n        System.out.println(\">>>endB: \" + endB);\n        \n        LocalDate dateAfterConsidered = \n            now.minusDays(daysBeforeToday);\n        return !(startA.isAfter(endB) || endA.isBefore(startB)) \n            ? true : false;\n    }\n\n    private long calculateOverlappedDays(Medicine medicine\n            , Medicine clashingMedicine\n            , long daysBeforeToday\n            , LocalDate now) {\n        System.out.println(\">>>entering calculateOverlappedDays()\");\n        LocalDate startA = getStartDate(medicine);\n        LocalDate endA = getEndDate(medicine);\n        LocalDate startB = getStartDate(clashingMedicine);\n        LocalDate endB = getEndDate(clashingMedicine);\n\n        LocalDate dateAfterConsidered = \n            now.minusDays(daysBeforeToday);\n        if (startA.isAfter(startB)) {\n            if (dateAfterConsidered.isAfter(startA) &&\n                    dateAfterConsidered.isBefore(endB)) {\n                return dateAfterConsidered.until(endB, ChronoUnit.DAYS);\n            }\n            if (now.isAfter(startA) &&\n                    now.isBefore(endB)) {\n                return startA.until(now, ChronoUnit.DAYS);\n            }\n            return startA.until(endB, ChronoUnit.DAYS);\n        } else {\n            System.out.println(\">>>startA is not after startB\");\n            if (dateAfterConsidered.isAfter(startB) &&\n                    dateAfterConsidered.isBefore(endA)) {\n                return dateAfterConsidered.until(endA, ChronoUnit.DAYS);\n            }\n            if (now.isAfter(startB) &&\n                    now.isBefore(endA)) {\n                return startB.until(now, ChronoUnit.DAYS);\n            }\n            return startB.until(endA, ChronoUnit.DAYS);\n        }\n    }\n\n    private LocalDate getStartDate(Medicine medicine) {\n        LocalDate startDate = \n            medicine.getPrescriptions().get(0).getDispenseDate();\n        return startDate;\n    }\n\n    private LocalDate getEndDate(Medicine medicine) {\n        int lastIndex = medicine.getPrescriptions().size() - 1;\n        LocalDate endDate = \n            medicine.getPrescriptions().get(lastIndex).getDispenseDate()\n            .plusDays(medicine.getPrescriptions().get(lastIndex)\n                .getDaysSupply());\n        return endDate;\n    }\n}","Medicine.java":"import java.util.List;\n\npublic class Medicine {\n    private List<Prescription> prescriptions;\n\n    public Medicine(String name, List<Prescription> prescriptions) {\n        this.prescriptions = prescriptions;\n    }\n\n    public List<Prescription> getPrescriptions() {\n        return this.prescriptions;\n    }\n}","Prescription.java":"import java.time.LocalDate;\n\npublic class Prescription {\n    private LocalDate dispenseDate;\n    private long daysSupply;\n\n    public Prescription(LocalDate dispenseDate, long daysSupply) {\n        this.dispenseDate = dispenseDate;\n        this.daysSupply = daysSupply;\n    }\n\n    public LocalDate getDispenseDate() {\n        return this.dispenseDate;\n    }\n\n    public long getDaysSupply() {\n        return this.daysSupply;\n    }\n}"}